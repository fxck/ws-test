<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>Zerops WebSocket Subscription Test</title>
  <style>
    * {
      box-sizing: border-box;
      margin: 0;
      padding: 0;
    }
    body {
      font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, sans-serif;
      padding: 20px;
      background: #1e1e1e;
      color: #d4d4d4;
    }
    .container {
      max-width: 1400px;
      margin: 0 auto;
    }
    h1 {
      margin-bottom: 20px;
      color: #4ec9b0;
    }
    .grid {
      display: grid;
      grid-template-columns: repeat(auto-fit, minmax(400px, 1fr));
      gap: 20px;
      margin-top: 20px;
    }
    .panel {
      background: #252526;
      border: 1px solid #3e3e42;
      border-radius: 6px;
      padding: 20px;
    }
    .panel h2 {
      margin-bottom: 15px;
      padding-bottom: 10px;
      border-bottom: 2px solid #3e3e42;
      color: #4ec9b0;
      font-size: 18px;
    }
    .status {
      padding: 12px;
      margin: 10px 0;
      border-radius: 4px;
      font-weight: 600;
    }
    .status.connected { background: #1e3a1e; color: #4ec9b0; border: 1px solid #4ec9b0; }
    .status.disconnected { background: #3a1e1e; color: #f48771; border: 1px solid #f48771; }
    .status.connecting { background: #3a3a1e; color: #dcdcaa; border: 1px solid #dcdcaa; }
    .log {
      height: 300px;
      overflow-y: auto;
      background: #1e1e1e;
      border: 1px solid #3e3e42;
      padding: 10px;
      font-family: 'Courier New', monospace;
      font-size: 12px;
      margin: 10px 0;
      border-radius: 4px;
    }
    .log-entry {
      margin: 3px 0;
      padding: 3px 0;
      white-space: pre-wrap;
      word-break: break-all;
    }
    .log-entry.ws { color: #569cd6; }
    .log-entry.http { color: #4ec9b0; }
    .log-entry.error { color: #f48771; }
    .log-entry.message { color: #c586c0; }
    .log-entry.info { color: #dcdcaa; }
    button {
      padding: 10px 16px;
      margin: 5px 5px 5px 0;
      cursor: pointer;
      border: 1px solid #3e3e42;
      border-radius: 4px;
      background: #0e639c;
      color: #fff;
      font-size: 13px;
      font-weight: 500;
      transition: all 0.2s;
    }
    button:hover {
      background: #1177bb;
      border-color: #1177bb;
    }
    button:disabled {
      background: #3e3e42;
      color: #666;
      cursor: not-allowed;
      border-color: #3e3e42;
    }
    button.secondary {
      background: #3e3e42;
      border-color: #3e3e42;
    }
    button.secondary:hover {
      background: #505050;
      border-color: #505050;
    }
    button.danger {
      background: #a1260d;
      border-color: #a1260d;
    }
    button.danger:hover {
      background: #c72e0d;
      border-color: #c72e0d;
    }
    label {
      display: block;
      margin: 10px 0 5px 0;
      color: #9cdcfe;
      font-size: 13px;
    }
    input[type="text"] {
      width: 100%;
      padding: 8px;
      background: #3c3c3c;
      border: 1px solid #3e3e42;
      border-radius: 4px;
      color: #d4d4d4;
      font-family: 'Courier New', monospace;
      font-size: 12px;
    }
    input[type="text"]:focus {
      outline: none;
      border-color: #007acc;
    }
    .subscription-item {
      padding: 10px;
      margin: 8px 0;
      border-left: 4px solid #3e3e42;
      background: #1e1e1e;
      border-radius: 4px;
    }
    .subscription-item.active { border-color: #4ec9b0; }
    .subscription-item.inactive { border-color: #f48771; }
    .subscription-item.unknown { border-color: #dcdcaa; }
    .subscription-item h3 {
      font-size: 14px;
      margin-bottom: 5px;
      color: #9cdcfe;
    }
    .subscription-item .detail {
      font-size: 11px;
      color: #858585;
      margin: 2px 0;
    }
    .counter {
      font-size: 32px;
      font-weight: bold;
      color: #4ec9b0;
      margin: 10px 0;
    }
    .info-row {
      display: flex;
      justify-content: space-between;
      padding: 8px 0;
      border-bottom: 1px solid #3e3e42;
      font-size: 13px;
    }
    .info-row:last-child {
      border-bottom: none;
    }
    .info-label {
      color: #858585;
    }
    .info-value {
      color: #d4d4d4;
      font-family: 'Courier New', monospace;
      font-size: 12px;
    }
    .controls {
      display: flex;
      flex-wrap: wrap;
      gap: 10px;
      margin-top: 15px;
    }
    .warning {
      background: #3a3a1e;
      border: 1px solid #dcdcaa;
      padding: 12px;
      border-radius: 4px;
      margin: 10px 0;
      color: #dcdcaa;
      font-size: 13px;
    }
  </style>
</head>
<body>
  <div class="container">
    <h1>üß™ Zerops WebSocket Subscription Test</h1>

    <div class="panel">
      <h2>‚öôÔ∏è Controls</h2>
      <div class="controls">
        <button onclick="app.simulateBackground()" class="secondary">üåô Simulate Background (60s)</button>
        <button onclick="app.disconnect()" class="danger">Disconnect</button>
        <button onclick="app.reset()" class="secondary">Reset All</button>
      </div>
    </div>

    <div class="grid">
      <div class="panel">
        <h2>üì° WebSocket Status</h2>
        <div id="wsStatus" class="status disconnected">Disconnected</div>

        <div class="info-row">
          <span class="info-label">Receiver ID:</span>
          <span class="info-value" id="receiverId">-</span>
        </div>
        <div class="info-row">
          <span class="info-label">WS Token:</span>
          <span class="info-value" id="wsToken">-</span>
        </div>
        <div class="info-row">
          <span class="info-label">Last Ping:</span>
          <span class="info-value" id="lastPing">-</span>
        </div>
        <div class="info-row">
          <span class="info-label">Last Pong:</span>
          <span class="info-value" id="lastPong">-</span>
        </div>
        <div class="info-row">
          <span class="info-label">Connection Time:</span>
          <span class="info-value" id="connectedTime">-</span>
        </div>
      </div>

      <div class="panel">
        <h2>üìä Total Messages Received</h2>
        <div id="totalCounter" class="counter">0</div>
        <div style="font-size: 12px; color: #858585;">
          Across all subscriptions
        </div>
      </div>
    </div>

    <div class="panel">
      <h2>üìã Subscription Status</h2>
      <div class="warning">
        ‚ö†Ô∏è This test replicates the EXACT behavior of the Zerops app. It does NOT implement re-subscription workarounds.
        We're testing to understand WHEN and WHY subscriptions stop working.
      </div>
      <div id="subscriptions"></div>
    </div>

    <div class="panel">
      <h2>üìù Event Log</h2>
      <button onclick="app.clearLog()" class="secondary" style="float: right;">Clear Log</button>
      <div id="log" class="log"></div>
    </div>
  </div>

  <script>
    const app = {
      ws: null,
      receiverId: null,
      wsToken: null,
      accessToken: null,
      clientId: null,
      backendUrl: 'https://api.app-prg1.zerops.io',
      connectedAt: null,
      subscriptions: {
        'service-stack-list': {
          name: 'service-stack__service-stack-base__list-subscription',
          entityType: 'service-stack',
          sent: null,
          lastMessage: null,
          count: 0
        },
        'service-stack-update': {
          name: 'service-stack__service-stack-base__update-subscription',
          entityType: 'service-stack',
          sent: null,
          lastMessage: null,
          count: 0
        },
        'project-list': {
          name: 'project__project-base__list-subscription',
          entityType: 'project',
          sent: null,
          lastMessage: null,
          count: 0
        },
        'project-update': {
          name: 'project__project-base__update-subscription',
          entityType: 'project',
          sent: null,
          lastMessage: null,
          count: 0
        },
        'notification-update': {
          name: 'notification__notification-base__update-subscription',
          entityType: 'user-notification',
          sent: null,
          lastMessage: null,
          count: 0
        },
        'process-list': {
          name: 'process__list-subscription',
          entityType: 'process',
          sent: null,
          lastMessage: null,
          count: 0
        },
        'process-update': {
          name: 'process__update-subscription',
          entityType: 'process',
          sent: null,
          lastMessage: null,
          count: 0
        },
      },
      processTimerInterval: null,
      pingInterval: null,
      backgroundTimeout: null,
      updateInterval: null,

      log(message, type = 'info') {
        const logDiv = document.getElementById('log');
        const entry = document.createElement('div');
        entry.className = `log-entry ${type}`;
        const timestamp = new Date().toISOString().split('T')[1].slice(0, -1);
        entry.textContent = `[${timestamp}] ${message}`;
        logDiv.appendChild(entry);
        logDiv.scrollTop = logDiv.scrollHeight;
        console.log(`[${type.toUpperCase()}] ${message}`);
      },

      clearLog() {
        document.getElementById('log').innerHTML = '';
        this.log('Log cleared', 'info');
      },

      updateDisplay() {
        // WebSocket status
        const statusDiv = document.getElementById('wsStatus');
        const receiverIdSpan = document.getElementById('receiverId');
        const wsTokenSpan = document.getElementById('wsToken');
        const connectedTimeSpan = document.getElementById('connectedTime');

        if (this.ws && this.ws.readyState === WebSocket.OPEN) {
          statusDiv.className = 'status connected';
          statusDiv.textContent = '‚úÖ Connected';

          if (this.connectedAt) {
            const seconds = Math.floor((Date.now() - this.connectedAt) / 1000);
            connectedTimeSpan.textContent = `${seconds}s`;
          }
        } else if (this.ws && this.ws.readyState === WebSocket.CONNECTING) {
          statusDiv.className = 'status connecting';
          statusDiv.textContent = 'üîÑ Connecting...';
        } else {
          statusDiv.className = 'status disconnected';
          statusDiv.textContent = '‚ùå Disconnected';
          connectedTimeSpan.textContent = '-';
        }

        receiverIdSpan.textContent = this.receiverId || '-';
        wsTokenSpan.textContent = this.wsToken ? `${this.wsToken.substring(0, 30)}...` : '-';

        // Subscriptions
        this.updateSubscriptionDisplay();

        // Total counter
        const total = Object.values(this.subscriptions).reduce((sum, sub) => sum + sub.count, 0);
        document.getElementById('totalCounter').textContent = total;
      },

      updateSubscriptionDisplay() {
        const subsDiv = document.getElementById('subscriptions');
        subsDiv.innerHTML = '';

        for (const [key, sub] of Object.entries(this.subscriptions)) {
          const div = document.createElement('div');
          div.className = 'subscription-item ' + (
            sub.sent ? (sub.lastMessage ? 'active' : 'unknown') : 'inactive'
          );

          const timeSinceSent = sub.sent ? Math.floor((Date.now() - sub.sent) / 1000) : null;
          const timeSinceMessage = sub.lastMessage ? Math.floor((Date.now() - sub.lastMessage) / 1000) : null;

          div.innerHTML = `
            <h3>${key.toUpperCase()}</h3>
            <div class="detail">Subscription: ${sub.name}</div>
            <div class="detail">Subscription sent: ${sub.sent ? `${timeSinceSent}s ago` : 'Not sent'}</div>
            <div class="detail">Last message: ${sub.lastMessage ? `${timeSinceMessage}s ago` : 'Never received'}</div>
            <div class="detail">Total messages: <strong>${sub.count}</strong></div>
          `;
          subsDiv.appendChild(div);
        }
      },

      generateReceiverId() {
        // Generate UUID v4 like the app does
        this.receiverId = 'xxxxxxxx-xxxx-4xxx-yxxx-xxxxxxxxxxxx'.replace(/[xy]/g, function(c) {
          const r = Math.random() * 16 | 0;
          const v = c === 'x' ? r : (r & 0x3 | 0x8);
          return v.toString(16);
        });
        this.log(`Generated receiverId: ${this.receiverId}`, 'info');
        return this.receiverId;
      },

      async getWebSocketToken() {
        if (!this.accessToken) {
          this.log('‚ùå Access token not configured', 'error');
          return null;
        }

        try {
          this.log('Requesting WebSocket token from backend...', 'http');
          const response = await fetch(`${this.backendUrl}/api/rest/public/web-socket/login`, {
            method: 'POST',
            headers: {
              'Content-Type': 'application/json',
              'Authorization': `Bearer ${this.accessToken}`
            },
            body: JSON.stringify({ accessToken: this.accessToken })
          });

          if (!response.ok) {
            const text = await response.text();
            throw new Error(`HTTP ${response.status}: ${text}`);
          }

          const data = await response.json();
          this.wsToken = data.webSocketToken;
          this.log(`‚úÖ Received WS token: ${this.wsToken.substring(0, 30)}...`, 'http');
          return this.wsToken;
        } catch (error) {
          this.log(`‚ùå Failed to get WS token: ${error.message}`, 'error');
          return null;
        }
      },

      async connect() {
        if (!this.receiverId) this.generateReceiverId();

        const token = await this.getWebSocketToken();
        if (!token) return;

        const protocol = this.backendUrl.startsWith('https') ? 'wss' : 'ws';
        const host = this.backendUrl.replace(/^https?:\/\//, '');
        const wsUrl = `${protocol}://${host}/api/rest/public/web-socket/${this.receiverId}/${token}`;

        this.log(`Connecting WebSocket to: ${wsUrl}`, 'ws');
        this.ws = new WebSocket(wsUrl);

        this.ws.onopen = () => {
          this.log('‚úÖ WebSocket connection OPENED', 'ws');
          this.connectedAt = Date.now();
          this.updateDisplay();
        };

        this.ws.onmessage = (event) => {
          const message = JSON.parse(event.data);

          if (message.type === 'SocketSuccess') {
            this.log(`‚úÖ Received SocketSuccess (chainId: ${message.chainId}, sessionId: ${message.sessionId})`, 'ws');
            this.startPingPong();
          } else if (message.type === 'pong') {
            const now = new Date().toLocaleTimeString();
            document.getElementById('lastPong').textContent = now;
            this.log(`‚¨ÖÔ∏è Received pong`, 'ws');
          } else {
            const subName = message.subscriptionName || 'unknown';
            this.log(`üì® Message received: ${message.type} [${subName}]`, 'message');

            // Track message by subscription
            for (const [key, sub] of Object.entries(this.subscriptions)) {
              if (message.subscriptionName === sub.name) {
                sub.lastMessage = Date.now();
                sub.count++;
                this.updateDisplay();
                break;
              }
            }
          }
        };

        this.ws.onerror = (error) => {
          this.log(`‚ùå WebSocket ERROR: ${error}`, 'error');
        };

        this.ws.onclose = (event) => {
          this.log(`‚ùå WebSocket CLOSED (code: ${event.code}, reason: ${event.reason || 'none'})`, 'ws');
          this.stopPingPong();
          this.connectedAt = null;
          this.updateDisplay();
        };

        this.updateDisplay();
      },

      startPingPong() {
        if (this.pingInterval) return;

        this.log('‚è±Ô∏è Starting ping/pong (every 15s)', 'info');
        this.pingInterval = setInterval(() => {
          if (this.ws && this.ws.readyState === WebSocket.OPEN) {
            this.ws.send(JSON.stringify({ type: 'ping' }));
            const now = new Date().toLocaleTimeString();
            document.getElementById('lastPing').textContent = now;
            this.log('‚û°Ô∏è Sent ping', 'ws');
          }
        }, 15000);
      },

      stopPingPong() {
        if (this.pingInterval) {
          clearInterval(this.pingInterval);
          this.pingInterval = null;
          this.log('‚èπÔ∏è Stopped ping/pong', 'info');
        }
      },

      async subscribe(entityName, subscriptionName, searchParams = [], additionalPayload = {}) {
        if (!this.clientId) {
          this.log('‚ùå Client ID not configured', 'error');
          return false;
        }

        const url = `${this.backendUrl}/api/rest/public/${entityName}/search`;
        const payload = {
          subscriptionName: subscriptionName,
          receiverId: this.receiverId,
          wsOutputType: 'listStream',
          search: [
            { name: 'clientId', operator: 'eq', value: this.clientId },
            ...searchParams
          ],
          ...additionalPayload
        };

        try {
          this.log(`üì§ POST /${entityName}/search [${subscriptionName}]`, 'http');
          const response = await fetch(url, {
            method: 'POST',
            headers: {
              'Content-Type': 'application/json',
              'Authorization': `Bearer ${this.accessToken}`
            },
            body: JSON.stringify(payload)
          });

          if (!response.ok) {
            const text = await response.text();
            throw new Error(`HTTP ${response.status}: ${text}`);
          }

          const data = await response.json();
          this.log(`‚úÖ Subscription created [${subscriptionName}] - ${data.items?.length || 0} items returned`, 'http');

          // Track subscription
          for (const [key, sub] of Object.entries(this.subscriptions)) {
            if (sub.name === subscriptionName) {
              sub.sent = Date.now();
              break;
            }
          }
          this.updateDisplay();
          return true;
        } catch (error) {
          this.log(`‚ùå Subscription failed [${subscriptionName}]: ${error.message}`, 'error');
          return false;
        }
      },

      async subscribeAll() {
        if (!this.ws || this.ws.readyState !== WebSocket.OPEN) {
          this.log('‚ùå WebSocket not connected', 'error');
          return;
        }

        this.log('‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê', 'info');
        this.log('Subscribing to all entities...', 'info');
        this.log('‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê', 'info');

        // Service Stack - list subscription (only clientId filter)
        await this.subscribe('service-stack', 'service-stack__service-stack-base__list-subscription');
        await new Promise(resolve => setTimeout(resolve, 100));

        // Service Stack - update subscription (only clientId filter)
        await this.subscribe('service-stack', 'service-stack__service-stack-base__update-subscription');
        await new Promise(resolve => setTimeout(resolve, 100));

        // Project - list subscription (only clientId filter)
        await this.subscribe('project', 'project__project-base__list-subscription');
        await new Promise(resolve => setTimeout(resolve, 100));

        // Project - update subscription (only clientId filter)
        await this.subscribe('project', 'project__project-base__update-subscription');
        await new Promise(resolve => setTimeout(resolve, 100));

        // Notification - update subscription (only clientId filter, with sort)
        await this.subscribe('user-notification', 'notification__notification-base__update-subscription', [], {
          sort: [{ name: 'created', ascending: false }]
        });
        await new Promise(resolve => setTimeout(resolve, 100));

        // Process - list subscription (with status and actionName filters)
        await this.subscribe('process', 'process__list-subscription', [
          { name: 'status', operator: 'in', value: ['RUNNING', 'PENDING'] },
          { name: 'actionName', operator: 'ne', value: 'instanceGroup.create' }
        ]);
        await new Promise(resolve => setTimeout(resolve, 100));

        // Process - update subscription (with status filters)
        await this.subscribe('process', 'process__update-subscription', [
          { name: 'status', operator: 'in', value: ['RUNNING', 'PENDING', 'FINISHED'] },
          { name: 'actionName', operator: 'ne', value: 'instanceGroup.create' }
        ]);

        this.log('‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê', 'info');
        this.log('‚úÖ All subscriptions sent', 'info');
        this.log('‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê', 'info');
      },

      async startProcessTimer() {
        if (this.processTimerInterval) {
          clearInterval(this.processTimerInterval);
          this.processTimerInterval = null;
          this.log('‚èπÔ∏è Stopped process timer', 'info');
          return;
        }

        if (!this.ws || this.ws.readyState !== WebSocket.OPEN) {
          this.log('‚ùå WebSocket not connected', 'error');
          return;
        }

        this.log('‚è±Ô∏è Starting process timer (re-subscribe every 160s)', 'info');

        // Immediate first subscription already done in subscribeAll
        // Then every 160 seconds (matching the real app)
        this.processTimerInterval = setInterval(async () => {
          this.log('‚è±Ô∏è Process timer tick - re-subscribing...', 'info');
          await this.subscribe('process', 'process__list-subscription', [
            { name: 'status', operator: 'in', value: ['RUNNING', 'PENDING'] },
            { name: 'actionName', operator: 'ne', value: 'instanceGroup.create' }
          ]);
        }, 160000);
      },

      disconnect() {
        if (this.ws) {
          this.ws.close();
          this.ws = null;
          this.log('üëã Manually disconnected', 'ws');
        }
        if (this.processTimerInterval) {
          clearInterval(this.processTimerInterval);
          this.processTimerInterval = null;
          this.log('‚èπÔ∏è Stopped process timer', 'info');
        }
        this.updateDisplay();
      },

      simulateBackground() {
        this.log('‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê', 'info');
        this.log('üåô SIMULATING BACKGROUND TAB', 'info');
        this.log('Stopping ping/pong for 60 seconds...', 'info');
        this.log('‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê', 'info');

        this.stopPingPong();

        if (this.backgroundTimeout) {
          clearTimeout(this.backgroundTimeout);
        }

        this.backgroundTimeout = setTimeout(() => {
          this.log('‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê', 'info');
          this.log('‚òÄÔ∏è RETURNING FROM BACKGROUND', 'info');
          this.log('‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê', 'info');

          if (this.ws && this.ws.readyState === WebSocket.OPEN) {
            this.log('‚úÖ WebSocket still appears open, sending ping...', 'ws');
            try {
              this.ws.send(JSON.stringify({ type: 'ping' }));
              this.startPingPong();
            } catch (error) {
              this.log(`‚ùå Ping failed: ${error.message}`, 'error');
              this.log('WebSocket connection is dead, need to reconnect manually', 'info');
            }
          } else {
            this.log('‚ùå WebSocket already closed, need to reconnect manually', 'ws');
          }
        }, 60000);
      },

      reset() {
        this.disconnect();

        if (this.backgroundTimeout) {
          clearTimeout(this.backgroundTimeout);
          this.backgroundTimeout = null;
        }

        this.receiverId = null;
        this.wsToken = null;
        this.connectedAt = null;

        for (const key in this.subscriptions) {
          this.subscriptions[key].sent = null;
          this.subscriptions[key].lastMessage = null;
          this.subscriptions[key].count = 0;
        }

        document.getElementById('lastPing').textContent = '-';
        document.getElementById('lastPong').textContent = '-';

        this.updateDisplay();
        this.log('‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê', 'info');
        this.log('üîÑ RESET COMPLETE', 'info');
        this.log('‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê', 'info');
      }
    };

    // Auto-update display every second
    app.updateInterval = setInterval(() => {
      app.updateDisplay();
    }, 1000);

    // Initialize from environment variables if available
    if (window.ENV) {
      if (window.ENV.BACKEND_URL) {
        app.backendUrl = window.ENV.BACKEND_URL;
      }
      if (window.ENV.ACCESS_TOKEN) {
        app.accessToken = window.ENV.ACCESS_TOKEN;
        app.log('‚úÖ Access token loaded from environment', 'info');
      }
      if (window.ENV.CLIENT_ID) {
        app.clientId = window.ENV.CLIENT_ID;
        app.log('‚úÖ Client ID loaded from environment', 'info');
      }
    }

    // Initial display
    app.updateDisplay();
    app.log('üöÄ Test app loaded', 'info');

    // Auto-start if credentials are available
    async function autoStart() {
      if (app.accessToken && app.clientId) {
        app.log('ü§ñ Auto-starting: credentials detected', 'info');

        // Connect WebSocket
        await app.connect();

        // Wait for connection to be established
        await new Promise(resolve => {
          const checkConnection = setInterval(() => {
            if (app.ws && app.ws.readyState === WebSocket.OPEN) {
              clearInterval(checkConnection);
              resolve();
            }
          }, 100);
        });

        // Subscribe to all entities
        app.log('ü§ñ Auto-subscribing to all entities', 'info');
        await app.subscribeAll();

        // Start process timer
        app.log('ü§ñ Auto-starting process timer', 'info');
        await app.startProcessTimer();

        app.log('‚úÖ Auto-start complete!', 'info');
      }
    }

    // Run auto-start after a short delay to let the page settle
    setTimeout(autoStart, 500);
  </script>
</body>
</html>
